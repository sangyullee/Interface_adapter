#include "ADC.h"

void ADC_init(void){ // ADC initialization  //Upd-6
PORTF=0x00; DDRF=0x00;
// ADC Clock frequency: 1000,000 kHz
// ADC Voltage Reference: Int., cap. on AREF
ADMUX=ADC_VREF_TYPE & 0xff;
ADCSRA=0x8C;
}

void adc_use (void)
{      
  ADCSRA=0b11011111;  //вкл 
};       


//-----------Функция автокалибровки АЦП-----------------   //Upd-7
void adc_calibrate (void)   //Поиск оптимального напряжения Vref 
{ 
  ADMUX &= 0xDF & 0x7F & 0xFE; ADMUX |= 0x40 | 0x0E;   //Регистр ADMUX: АЦП 10 бит, Vref=AVCC (5B), ИОН=1,23В    
  ADCSRA &= 0xDF & 0xFC; ADCSRA |= 0x80 | 0x40 | 0x04; //Регистр ADCSRA: вкл. АЦП, одиночный пуск, Fацп=62 кГц  
  for (volt=0, adc_calib_cnt=100; adc_calib_cnt>0; adc_calib_cnt--) //Усреднение 100 замеров 
  {    
    ADCSRA |= 0x40;        //Запуск нового измерения АЦП 
    while (ADCSRA & 0x40);   //Проверка окончания замера 
    volt += ADCL;    //Чтение младших 8 битов результата 
    volt += ((int)ADCH << 8);    //Плюс два старших бита 
  }                   //Окончание 100 замеров напряжения 
  for (avcc=4750; avcc<5250; avcc++) //Диапазон AVCC, мВ 
  { 
     adc_tmp = volt*avcc/1024; //Текущее значение ИОН (1,23В) 
     if (adc_tmp > ION) {delta=adc_tmp-ION;}   //Положительная разность 
     else delta=ION-adc_tmp;           //Отрицательная разность 
     if (delta < d){d=delta; vref=avcc;} //Если меньше минимальной разности - запомнить новую минимальную разность и оптимальное напряжение Vref
  }                                      //Окончание сохранения новых значений, Окончание поиска оптимального напряжения Vref  
}                 //Окончание функции автокалибровки АЦП 

uint16_t adc_get_volt(void)
{
   return vref-adc_result*vref/1024;
}

/*
//Автокалибровка АЦП,=AVR. Ступень 8=, РА, №9, 2005 г     =1
//Make: avr83,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
//Фьюзы: SUT0=CKSEL3=CKSEL2=CKSEL1="0" (Генератор 1 МГц)  =3
#include <avr/io.h>             //Библиотека ввода-вывода =4
#define RIZM 200  //Сопротивление измер. резистора в Омах =5
#define ION 1298 //Напряжение внутреннего ИОН (1,23) в мВ =6
extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =7
extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =8
extern void lcd_init(void);           //Инициализация ЖКИ =9
unsigned char t0[]=" ==WATTMETER==          mWt     "; //=10
unsigned long vref=0,volt,watt,delta,i,d=200,avcc;     //=11
unsigned int a;                //Вспомогательный счетчик =12
//-----------Функция автокалибровки АЦП----------------- =13
void calib (void)   //Поиск оптимального напряжения Vref =14
{ //Регистр ADMUX: АЦП 10 бит, Vref=AVCC (5B), ИОН=1,23В =15
        ADMUX &= 0xDF & 0x7F & 0xFE; ADMUX |= 0x40 | 0x0E;   //=16
//Регистр ADCSRA: вкл. АЦП, одиночный пуск, Fацп=62 кГц  =17
        ADCSRA &= 0xDF & 0xFC; ADCSRA |= 0x80 | 0x40 | 0x04; //=18
  for (volt=0, a=100; a>0; a--) //Усреднение 100 замеров =19
  {    ADCSRA |= 0x40;        //Запуск нового измерения АЦП =20
          while (ADCSRA & 0x40);   //Проверка окончания замера =21
          volt += ADCL;    //Чтение младших 8 битов результата =22
    volt += ((int)ADCH << 8);    //Плюс два старших бита =23
        }                   //Окончание 100 замеров напряжения =24
        for (avcc=4750; avcc<5250; avcc++) //Диапазон AVCC, мВ =25
  { i = volt*avcc/102400; //Текущее значение ИОН (1,23В) =26
          if (i > ION) delta=i-ION;   //Положительная разность =27
          else delta=ION-i;           //Отрицательная разность =28
          if (delta < d)    //Если меньше минимальной разности =29
    { d=delta;    //Запомнить новую минимальную разность =30
      vref=avcc; //Запомнить оптимальное напряжение Vref =31
    }              //Окончание сохранения новых значений =32
  }      //Окончание поиска оптимального напряжения Vref =33
}                 //Окончание функции автокалибровки АЦП =34
//================ОСНОВНАЯ ПРОГРАММА==================== =35
int main(void)               //Начало основной программы =36
{ PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =37
  PORTC = 0xF0; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =38
  lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =39
  for (lcd_com(0x80), a=0; a<32; a++)  //Начальный текст =40
        { if (a==16) lcd_com(0xC0); //Переход на нижнюю строку =41
          lcd_dat(t0[a]);             //Вывод текущего символа =42
        }       //Окончание вывода начальной надписи WATTMETER =43
        calib(); //Автокалибровка АЦП по внутреннему ИОН 1,23В =44
        ADMUX &= 0xF3; ADMUX |= 0x03;   //Подключение канала-3 =45
        ADCSRA |= 0x20 | 0x40;   //Пуск постоянных замеров АЦП =46
        while (1)                           //Бесконечный цикл =47
        { for (a=65000; a>0; a--);       //Пауза для индикации =48
          volt = ADCL;     //Чтение младших 8 битов результата =49
    volt += ((int)ADCH << 8);    //Плюс два старших бита =50
          watt=(vref-volt*vref/1024)*(volt*vref/1024)/RIZM; // =51
                lcd_com(0xC4);               //Установка курсора ЖКИ =52
                lcd_dat(watt/1000 + 0x30); //Единицы милливатт (мВт) =53
				lcd_dat(',');	lcd_dat((watt/100)%10 +0x30); //0,1мВт =54
		}                     //Переход к новому измерению АЦП =55
}              //WinAVR-20050214, длина кода 1342 байтов =56



//Осциллограф на ЖКИ (АЦП),=AVR. Ступень 9=, РА, №10-2005 =1
//Make: avr91,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
//Фьюзы: SUT0=CKSEL3=CKSEL1=CKSEL0="0" (Генератор 8 МГц)  =3
#include <avr/io.h>             //Библиотека ввода-вывода =4
extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =5
extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =6
extern void lcd_init(void);           //Инициализация ЖКИ =7
unsigned char t[]="        јєc/гe» ";    //Текст заставки =8
//================ОСНОВНАЯ ПРОГРАММА===================== =9
int main(void)               //Начало основной программы =10
{ unsigned char a, b, c, scan, ur, h;         //Счетчики =11
  unsigned int izm, d, k;       //Счетчики больших чисел =12
		unsigned int osc[32];   //Массив амплитуд осциллографа =13
		PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =14
  PORTC = 0xC2; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =15
		ADMUX &= 0x7F; ADMUX |= 0x20 | 0x40;  //8-10 бит, AVCC =16
//Регистр ADCSRA: вкл.АЦП, постоян. измерен., Fацп=1 МГц =17
		ADCSRA &= 0xFB; ADCSRA |= 0x80 | 0x40 | 0x20 | 0x03; //=18
		lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =19
		lcd_com(0x40); lcd_dat(0x00); //Начало знакогенератора =20
		for (a=1; a<63; a++)  //Загрузка 8 свободных знакомест =21
		{ if (a%7 == 0) lcd_dat(0x1F);      //В строке 5 точек =22
	   else lcd_dat(0x00);       //Пустая строка, нет точек =23
		}       //Окончание загрузки 62 байтов знакогенератора =24
		lcd_dat(0x00); //Последний (64-й) байт знакогенератора =25
		for (lcd_com(0xC0), a=0; a<16; a++) lcd_dat(t[a]);  // =26
		while (1)                 //Бесконечный цикл измерений =27
		{ ADMUX &=0xF5; ADMUX |=0x05;     //Канал-5, РАЗВЕРТКА =28
		  for (a=5; a>0; a--) for (d=60000; d>0; d--);	//Пауза =29
				scan = (ADCH <= 5)? 1 : (ADCH - 4); //Развертка, мкс =30
				ADMUX &=0xF4; ADMUX |=0x04; //Канал-4, УРОВЕНЬ СИНХР =31
				lcd_com(0xC2);               //Установка курсора ЖКИ =32
				for (k=13*scan, d=10000, b=5; b > 0; b--, d=d/10) // =33
    { lcd_dat(((k / d)%10) + 0x30); //Вывод текущ. цифры =34
    }  //Окончание вывода 5 цифр времени развертки в мкс =35
				ur = (ADCH <= 10)? 0 : ADCH; //Уровень синхрониз., В =36
		  ADMUX &= 0xF3; ADMUX |= 0x03; //Канал-3, ВХОД осцил. =37
				for(lcd_com(0x80), a=0; a<32; a++)   //32 замера АЦП =38
				{ for (izm=0, b=scan; b > 0; b--)  //Время развертки =39
						{ while (!(ADCSRA & 0x10));   //Проверка измерения =40
		      ADCSRA |= 0x10;   //Разрешение следующего замера =41
        izm += ADCH;             //Накопление результата =42
						}                //Окончание очередного замера АЦП =43
						osc[a] = izm;        //Заполнение массива амплитуд =44
				}              	//Окончание 32 замеров амплитуды АЦП =45
				lcd_com(0x0D);               //Включение курсора ЖКИ =46
				if (!ur)	for (a=0; a<16; a++) lcd_dat((osc[a]/scan)/32);
				else  //Если синхронизация или остановка изображения =48
				{	if (ur < 0xF0)    //Если нет остановки изображения =49
				  { for (a=b=c=h=0; a<16; a++) //Поиск синхронизации =50
        { if (bit_is_set(PINB,PB0)) c=1; //Кнопка SB1(+) =51
								  else b=1;   //Иначе синхронизация от <+> к <-> =52
								  if((osc[a+b]/scan<(ur-3))&&(osc[a+c]/scan>(ur+3)))
								  { h=a; a=32;       //Досрочный выход из поиска =54
										}            //Синхронизация выполнена успешно =55
						  }     //Окончание процедуры поиска синхронизации =56
						  for (a=h; a<(h+16); a++) lcd_dat((osc[a]/scan)/32); 
						}  //Окончание прорисовки графика с синхронизацией =58
						else lcd_com(0x0C);  //Выкл. курсора при остановке =59
				}        //Завершение процедуры поиска синхронизации =60
		}               //Переход к новому циклу измерений АЦП =61
}               //WinAVR-20050214, длина кода 882 байтов =62



//Запоминающий осциллограф,=AVR. Ступень 10=, РА №11-2005 =1
//Make:avr101,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
//Фьюзы: SUT0=CKSEL3=CKSEL2=CKSEL1="0" (Генератор 1 МГц)  =3
#include <avr/io.h>             //Библиотека ввода-вывода =4
extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =5
extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =6
extern void lcd_init(void);           //Инициализация ЖКИ =7
#define TIME 30 //Условная длительность одного замера АЦП =8
unsigned char t[]="Cїapї ё·јepeЅё№";     //Текст заставки =9
//================ОСНОВНАЯ ПРОГРАММА==================== =10
int main(void)               //Начало основной программы =11
{ unsigned char u1[450], u2[450]; //Массивы данных осцил.=12
		unsigned int a, b, c, d, h=0;        //Счетчики данных =13
  PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =14
  PORTC = 0xC2; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =15
		ADMUX &= 0x7F; ADMUX |= 0x20 | 0x40;  //8-10 бит, AVCC =16
//Регистр ADCSRA: включить АЦП, однократно, Fацп=125 кГц =17
		ADCSRA &= 0xDF & 0xFB; ADCSRA |= 0x80 | 0x40 | 0x03; //=18
		lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =19
		lcd_com(0x40); lcd_dat(0x00); //Начало знакогенератора =20
		for (a=1; a<63; a++)  //Загрузка 8 свободных знакомест =21
		{ if (a%7 == 0) lcd_dat(0x1F);      //В строке 5 точек =22
	   else lcd_dat(0x00);       //Пустая строка, нет точек =23
		}       //Окончание загрузки 62 байтов знакогенератора =24
		lcd_dat(0x00); //Последний (64-й) байт знакогенератора =25
		for(lcd_com(0x80),a=0; a<15; a++) lcd_dat(t[a]); //ЖКИ =26
		do  //Цикл проверки снижения напряжения Uзап менее 4 В =27
		{ ADMUX &=0xF3; ADMUX |=0x03; ADCSRA |=0x40; //Канал-3 =28
		  while (ADCSRA & 0x40);   //Проверка окончания замера =29
		} while (ADCH > 0xCC); //Проверять, пока уровень > 4 В =30
		lcd_com(0x0C); //Выключение курсора при начале замеров =31
		for (a=0; a<450; a++) //Цикл заполнения массива данных =32
		{ for (c=d=0, b=TIME; b>0; b--)   //Усреднение замеров =33
		  { ADMUX &=0xF4; ADMUX |=0x04; ADCSRA |=0x40; //Кан.4 =34
		    while (ADCSRA & 0x40); //Проверка окончания замера =35
		    c += ADCH;  //Накопление амплитуды АЦП по каналу-4 =36
				  ADMUX &=0xF5; ADMUX |=0x05; ADCSRA |=0x40; //Кан.5 =37
		    while (ADCSRA & 0x40); //Проверка окончания замера =38
		    d += ADCH;  //Накопление амплитуды АЦП по каналу-5 =39
				}         //Окончание цикла замеров с каналов-4 и -5 =40
				u1[a] = c/(TIME*32);  //Усредненный текущий замер U1 =41
				u2[a] = d/(TIME*32);  //Усредненный текущий замер U2 =42
		}         //Окончание заполнения массива данных U1, U2 =43
  while (1) //Бесконечный цикл индикации, повтор - сброс =44
		{ lcd_com(0x80);  //Установка курсора в верхней строке =45
		  for(a=h; a < h+15; a++) lcd_dat(u1[a]);  //График U1 =46
				lcd_com(0xC0);   //Установка курсора в нижней строке =47
				for(a=h; a < h+15; a++) lcd_dat(u2[a]);  //График U2 =48
				lcd_dat(0x30 + h/15);  //Условный номер блока данных =49
				if (bit_is_clear(PINB,PB0))     //Нажатие кнопки SB1 =50
    { if ((h += 15) > 435) h=0;  //Следующий блок данных =51
      for (c=65000; c>0; c--);  //Длительность индикации =52
				}         //Окончание увеличения номера блока данных =53
				if (bit_is_clear(PINB,PB1))     //Нажатие кнопки SB2 =54
    { h = (h < 15)? 435 : (h-15); //Предыдущий блок дан. =55
      for (c=65000; c>0; c--);  //Длительность индикации =56
				}         //Окончание уменьшения номера блока данных =57
		}               //Переход к прорисовке графиков данных =58
}               //WinAVR-20050214, длина кода 752 байтов =59

*/